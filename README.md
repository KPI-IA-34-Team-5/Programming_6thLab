# Лабораторна робота №6
## Тема: MultiThreading
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Аналіз точності і часу виконання:
**Точність:**
— Всі вапіанти вирішення дають однаковий результат, оскільки в основі все одно лежить звичайна формула АП — просто додавання чисел

**Час виконання:**
— Логічно, що чим більше тредів, тим менше буде час виконання, наприклад, перегляд резюме однією людиною буде йти довше ніж наприклад 2 або 4.

**Графік:**

![sdkjnsndf](https://github.com/KPI-IA-34-Team-8/Programming_6thLab/blob/main/t(k).png)

---
## Контрольні питання:

### 1. Чим процес відрізняється від треда?
Процес і потік (також відомий як "тред") - це два основних концепти в операційних системах і мовах програмування для організації та виконання програмного коду, але вони мають різні аспекти і призначення. 
Ось їхні відмінності:

**Процес:**
Процес - це незалежний об'єкт в операційній системі, який містить в собі виконуваний програмний код, пам'ять, ресурси та інші атрибути.
Кожен процес має своє власне середовище виконання, в тому числі свій власний адресний простір, таблицю процесів, стек викликів тощо.
Процеси можуть бути запущені, призупинені, відновлені та завершені операційною системою.
Кожен процес може мати один або більше потоків, які виконують свої завдання паралельно.

**Потік (тред):**
Потік (або "тред") - це послідовність виконання програмного коду всередині процесу.
У межах одного процесу може існувати багато потоків, які можуть виконувати свою роботу паралельно або послідовно.
Потоки ділять загальні ресурси та пам'ять процесу і можуть спільно працювати або конкурувати за них.
Потоки можуть бути створені, виконані, призупинені та завершені всередині процесу.

### 2. В чому полягає різниця між кооперативною та витискальною багатозадачністю? Яка з цих моделей реалізована у Java?

Кооперативна та витискальна багатозадачність - це дві різні моделі виконання багатьох процесів або потоків в одному середовищі. 
Ось їх різниця:

**Кооперативна багатозадачність:**
У цій моделі процеси або потоки добровільно передають управління іншим процесам або потокам.
Кожен процес або потік виконується до тих пір, поки не передасть управління іншому процесу або потоку або завершить своє виконання.
Використовується зазвичай в операційних системах, які мають підтримку для спільного використання ресурсів.

**Витискальна багатозадачність:**
У цій моделі операційна система самостійно вирішує, які процеси або потоки отримують час на виконання.
Процеси або потоки можуть бути перервані системою без їхньої згоди.
Це дозволяє операційній системі краще керувати ресурсами та забезпечити кращу реактивність системи.

**У Java використовується витискальна багатозадачність.** Управління потоками в Java здійснюється віртуальною машиною Java (JVM) з використанням планувальника потоків, який визначає, який потік отримає доступ до ресурсів процесора. Java забезпечує низку класів та інтерфейсів для створення та управління потоками, наприклад, клас Thread та інтерфейс Runnable.

### 3. Пояснити діаграму станів об’єкта класу Thread. Чим стан «Running» відрізняється від стану «Runnable»?

Діаграма станів об'єкта класу Thread в Java може бути представлена наступним чином:

*New (Новий):* Потік був створений, але ще не запущений методом start().
*Runnable (Виконується):* Потік готовий до виконання, але його виконання ще не почалося або було призупинено, і він чекає на виконання процесором. Це може бути внаслідок того, що інші потоки вже використовують процесор або потік був призупинений за допомогою методу suspend(), який застарів та не рекомендується до використання.
*Running (Виконується):* Потік активно виконується, виконує свій код.
*Blocked (Блокований):* Потік чекає на відповідь або певну подію, наприклад, виклик методу wait(), отримання блокуючого введення/виведення (I/O), або спроба отримати блокований ресурс.
*Dead (Мертвий):* Потік завершив свою роботу або виконання.

Відмінності між станами "Running" та "Runnable":

**Runnable (Виконується):** В цьому стані потік готовий до виконання, але його виконання ще не почалося або було призупинено.

**Running (Виконується):** В цьому стані потік активно виконується, виконує свій код. Це означає, що процесор наразі виконує інструкції, пов'язані з потоком, і він знаходиться в режимі виконання.

### 4. Коли і як слід використовувати методи run() та start() класу Thread?

Методи run() та start() класу Thread використовуються для запуску виконання коду в окремому потоці. 
Однак, їхнє використання відрізняється:

**Метод run():**
Метод run() містить код, який ви хочете виконати в окремому потоці.
Виклик методу run() виконує код в поточному потоці виконання, а не створює новий потік.
Зазвичай виклик методу run() безпосередньо використовується в разі, коли ви хочете виконати код в тому ж потоці, який вже виконується, і не хочете створювати новий потік.

**Метод start():**
Метод start() викликається для запуску виконання коду з методу run() в новому потоці.
Виклик методу start() створює новий потік виконання, в якому буде викликатися метод run().
Важливою відмінністю є те, що потрібно викликати саме start(), якщо ви хочете, щоб код був виконаний в окремому потоці. Виклик run() просто виконає код у поточному потоці, не створюючи новий потік.

Отже, коли використовувати кожен з цих методів:

Використовуйте **run()** тоді, коли ви хочете просто виконати код у поточному потоці без створення нового.
Використовуйте **start()** тоді, коли вам потрібно виконати код у новому окремому потоці, щоб виконання не блокувало головний потік.

### 5. Чому не слід використовувати deprecated-методи класу Thread?
- **Можливість видалення у майбутніх версіях:** Методи, які вважаються застарілими, зазвичай позначені як такі через їхню неоптимальність або небезпеку, або через те, що їхній функціонал замінений кращими або безпечнішими альтернативами. Існує ризик того, що ці методи можуть бути повністю видалені у майбутніх версіях мови або платформи.
- **Підтримка інших функціональних альтернатив:** Зазвичай методи, які вважаються застарілими, мають сучасніший еквівалент, який пропонує кращий функціонал або безпеку. Використання сучасних альтернатив може підвищити читабельність та ефективність вашого коду.
- **Підвищення рівня надійності:** Застарілі методи можуть містити помилки або бути менш надійними в порівнянні з сучасними альтернативами. Використання застарілих методів може збільшити ймовірність виникнення помилок у вашому програмному коді.
- **Підтримка кращої читабельності та зрозумілості коду:** Використання застарілих методів може призвести до збентеження інших розробників, які читають ваш код. Використання сучасних альтернатив може полегшити зрозуміння та підтримку коду.

### 6. Для чого потрібен метод join()?

Метод join() використовується для управління потоками в Java і дозволяє поточному потоку чекати на завершення іншого потоку. Коли викликається метод join() на об'єкті потоку, який ви хочете дочекатися, поточний потік буде зупинений до тих пір, поки цей потік не завершиться.

Головна причина використання методу join() полягає в тому, щоб гарантувати порядок виконання операцій між потоками або зібрати результати виконання потоків.

Наприклад, якщо у вас є головний потік, який створює певну кількість додаткових потоків для виконання певних обчислень, і вам потрібно дочекатися, поки всі ці потоки завершаться перед продовженням роботи головного потоку, ви можете використовувати join() для цього.

Наприклад:

```java
Thread t1 = new Thread(() -> {
    // Обчислення або дії, які виконує перший потік
});
Thread t2 = new Thread(() -> {
    // Обчислення або дії, які виконує другий потік
});

// Запуск потоків
t1.start();
t2.start();

// Дочекатися завершення обох потоків перед продовженням виконання головного потоку
try {
    t1.join();
    t2.join();
} catch (InterruptedException e) {
    // Обробка винятку
}

// Код, що виконується після завершення обох потоків
```
У цьому прикладі головний потік дочекається завершення обох t1 та t2, перш ніж продовжить своє виконання після методу join().
